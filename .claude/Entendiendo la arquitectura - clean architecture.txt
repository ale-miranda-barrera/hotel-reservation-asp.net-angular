# üèóÔ∏è CLEAN ARCHITECTURE EXPLICADA - Hotel Reservation System

## üìå ENTENDER CLEAN ARCHITECTURE EN 3 FRASES

Clean Architecture es **separar el c√≥digo en capas conc√©ntricas** donde:
1. **Interior** = L√≥gica de negocio pura (sin dependencias)
2. **Intermedio** = Casos de uso que orquestan el negocio
3. **Exterior** = Detalles t√©cnicos (BD, UI, APIs externas)

**Regla de oro:** Las dependencias siempre apuntan hacia adentro. El exterior NO debe tocar el interior.

---

## üéØ EN TU PROYECTO: CAPAS CONCRETAS

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PRESENTACI√ìN (UI/API)               ‚îÇ
‚îÇ              HotelsController.cs                       ‚îÇ
‚îÇ              ReservationsController.cs                 ‚îÇ
‚îÇ  ‚Üì (Depende de)                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ              APPLICATION (Casos de Uso)                ‚îÇ
‚îÇ              HotelService.cs                           ‚îÇ
‚îÇ              ReservationService.cs                     ‚îÇ
‚îÇ  ‚Üì (Depende de)                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ          INFRASTRUCTURE (Detalles t√©cnicos)            ‚îÇ
‚îÇ          HotelRepository.cs                            ‚îÇ
‚îÇ          ReservationRepository.cs                      ‚îÇ
‚îÇ          AppDbContext.cs                              ‚îÇ
‚îÇ  ‚Üì (Depende de)                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ              DOMAIN (N√∫cleo de negocio)               ‚îÇ
‚îÇ              Hotel.cs (entidad)                        ‚îÇ
‚îÇ              Reservation.cs (entidad)                  ‚îÇ
‚îÇ              IHotelRepository (interfaz)               ‚îÇ
‚îÇ              IReservationRepository (interfaz)         ‚îÇ
‚îÇ              ‚ö†Ô∏è SIN DEPENDENCIAS EXTERNAS             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Lo crucial:** Domain NO importa nada. Application importa Domain. Infrastructure importa Domain. Presentation importa Application.

---

## üî¥ EJEMPLO CONCRETO: CREAR UNA RESERVA

### QU√â PASA EN CADA CAPA

#### CAPA 1: DOMAIN (L√≥gica de negocio pura - Sin cambiar)

```csharp
// Domain/Entities/Reservation.cs
public class Reservation
{
    public int Id { get; set; }
    public int HotelId { get; set; }
    public string GuestName { get; set; }
    public DateTime CheckInDate { get; set; }
    public DateTime CheckOutDate { get; set; }
    public ReservationStatus Status { get; set; }
    
    // ‚ö†Ô∏è PURE BUSINESS LOGIC (Sin efectos secundarios)
    public decimal CalculatePrice(decimal nightlyRate)
    {
        int nights = (CheckOutDate - CheckInDate).Days;
        return nights * nightlyRate;
    }
    
    // ‚ö†Ô∏è VALIDACI√ìN DE NEGOCIO
    public bool IsValidReservation()
    {
        return CheckOutDate > CheckInDate && 
               !string.IsNullOrEmpty(GuestName);
    }
}

// Domain/Interfaces/IReservationRepository.cs
public interface IReservationRepository
{
    Task<Reservation> GetByIdAsync(int id);
    Task AddAsync(Reservation reservation);
    Task SaveChangesAsync();
}
```

**Qu√© ves aqu√≠:**
- ‚úÖ M√©todos puros (solo manipulan datos)
- ‚úÖ L√≥gica de negocio (calcular precio, validar)
- ‚úÖ Sin DbContext
- ‚úÖ Sin HttpClient
- ‚úÖ Sin dependencias de UI
- ‚úÖ SIN `using System.Data;` nada de eso

**Por qu√©:** Si ma√±ana cambias de BD (SQL Server ‚Üí MongoDB), el Domain no cambia. Si cambias de HTTP a gRPC, el Domain no cambia.

---

#### CAPA 2: APPLICATION (Casos de uso que orquestan)

```csharp
// Application/Services/IReservationService.cs
public interface IReservationService
{
    Task<ReservationDto> CreateReservationAsync(CreateReservationDto dto);
    Task<IEnumerable<ReservationDto>> GetReservationsByGuestAsync(string email);
}

// Application/Services/ReservationService.cs
public class ReservationService : IReservationService
{
    // ‚ö†Ô∏è INYECTAMOS ABSTRACCIONES (interfaces), NO implementaciones
    private readonly IReservationRepository _reservationRepository;
    private readonly IHotelRepository _hotelRepository;
    private readonly ILogger<ReservationService> _logger;
    
    public ReservationService(
        IReservationRepository reservationRepository,
        IHotelRepository hotelRepository,
        ILogger<ReservationService> logger)
    {
        _reservationRepository = reservationRepository;
        _hotelRepository = hotelRepository;
        _logger = logger;
    }
    
    public async Task<ReservationDto> CreateReservationAsync(CreateReservationDto dto)
    {
        try
        {
            // PASO 1: Validar que el hotel existe (l√≥gica de negocio)
            var hotel = await _hotelRepository.GetByIdAsync(dto.HotelId);
            if (hotel == null)
            {
                _logger.LogWarning($"Hotel {dto.HotelId} no encontrado");
                throw new InvalidOperationException("Hotel no existe");
            }
            
            // PASO 2: Crear la entidad (con l√≥gica pura de Domain)
            var reservation = new Reservation
            {
                HotelId = dto.HotelId,
                GuestName = dto.GuestName,
                GuestEmail = dto.GuestEmail,
                CheckInDate = dto.CheckInDate,
                CheckOutDate = dto.CheckOutDate,
                Status = ReservationStatus.Pending
            };
            
            // PASO 3: Validar usando l√≥gica de Domain
            if (!reservation.IsValidReservation())
            {
                throw new InvalidOperationException("Reserva inv√°lida");
            }
            
            // PASO 4: Calcular precio (l√≥gica de Domain)
            var nightlyRate = 100m; // En realidad, vendr√≠a del hotel
            reservation.TotalPrice = reservation.CalculatePrice(nightlyRate);
            
            // PASO 5: Persistir (delegamos al repositorio)
            await _reservationRepository.AddAsync(reservation);
            await _reservationRepository.SaveChangesAsync();
            
            _logger.LogInformation($"Reserva {reservation.Id} creada para {dto.GuestName}");
            
            // PASO 6: Retornar DTO (convertimos entidad a DTO)
            return new ReservationDto
            {
                Id = reservation.Id,
                GuestName = reservation.GuestName,
                Status = reservation.Status.ToString(),
                TotalPrice = reservation.TotalPrice
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creando reserva");
            throw;
        }
    }
}

// Application/DTOs/CreateReservationDto.cs
public class CreateReservationDto
{
    public int HotelId { get; set; }
    public string GuestName { get; set; }
    public string GuestEmail { get; set; }
    public DateTime CheckInDate { get; set; }
    public DateTime CheckOutDate { get; set; }
}

// Application/DTOs/ReservationDto.cs (Lo que retornamos)
public class ReservationDto
{
    public int Id { get; set; }
    public string GuestName { get; set; }
    public string Status { get; set; }
    public decimal TotalPrice { get; set; }
}
```

**Qu√© ves aqu√≠:**
- ‚úÖ **Orquestaci√≥n:** "Haz esto, luego esto, luego esto"
- ‚úÖ **Inyecci√≥n de dependencias:** Recibe interfaces (IReservationRepository), no clases concretas
- ‚úÖ **DTOs:** Convierte Domain ‚Üí DTO para no exponer detalles internos
- ‚úÖ **Logging:** Registra eventos importantes
- ‚úÖ **Validaci√≥n:** Usa m√©todos de Domain para validar
- ‚úÖ **Sin BD:** No sabe que existe PostgreSQL

**Por qu√© es importante:**
- Si ma√±ana necesitas crear 100 reservas en batch, reutilizas esta clase
- Si necesitas cambiar la l√≥gica de c√°lculo de precio, SOLO cambias Domain + aqu√≠
- La l√≥gica est√° en un lugar, no esparcida en 10 controllers

---

#### CAPA 3: INFRASTRUCTURE (Detalles t√©cnicos de persistencia)

```csharp
// Infrastructure/Repositories/ReservationRepository.cs
public class ReservationRepository : IReservationRepository
{
    // ‚ö†Ô∏è AQU√ç VIVE POSTGRESQL
    private readonly AppDbContext _context;
    
    public ReservationRepository(AppDbContext context)
    {
        _context = context;
    }
    
    public async Task<Reservation> GetByIdAsync(int id)
    {
        // ‚ö†Ô∏è AQU√ç EST√Å EL SQL (impl√≠cito en EF Core)
        return await _context.Reservations.FirstOrDefaultAsync(r => r.Id == id);
    }
    
    public async Task AddAsync(Reservation reservation)
    {
        // ‚ö†Ô∏è AGREGAR A LA BD
        await _context.Reservations.AddAsync(reservation);
    }
    
    public async Task SaveChangesAsync()
    {
        // ‚ö†Ô∏è COMMIT A LA BD
        await _context.SaveChangesAsync();
    }
}

// Infrastructure/Data/AppDbContext.cs
public class AppDbContext : DbContext
{
    public DbSet<Hotel> Hotels { get; set; }
    public DbSet<Reservation> Reservations { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // ‚ö†Ô∏è MAPEO RELACIONAL (1:N)
        modelBuilder.Entity<Hotel>()
            .HasMany(h => h.Reservations)
            .WithOne(r => r.Hotel)
            .HasForeignKey(r => r.HotelId);
    }
}
```

**Qu√© ves aqu√≠:**
- ‚úÖ **Solo persistencia:** Aqu√≠ vive la BD
- ‚úÖ **DbContext:** Configuraci√≥n EF Core
- ‚úÖ **Sin l√≥gica:** Solo leer/escribir datos
- ‚úÖ **Implementa interfaces:** ReservationRepository implementa IReservationRepository

**Por qu√© es importante:**
- Cambiar de PostgreSQL a MongoDB = SOLO cambias esta capa
- La l√≥gica (IReservationService) sigue igual
- Los controllers no notan el cambio

---

#### CAPA 4: PRESENTATION (API REST)

```csharp
// Presentation/Controllers/ReservationsController.cs
[ApiController]
[Route("api/[controller]")]
public class ReservationsController : ControllerBase
{
    // ‚ö†Ô∏è INYECTAMOS EL SERVICIO (interfaz)
    private readonly IReservationService _reservationService;
    
    public ReservationsController(IReservationService reservationService)
    {
        _reservationService = reservationService;
    }
    
    // POST /api/reservations
    [HttpPost]
    public async Task<ActionResult<ReservationDto>> CreateReservation(
        [FromBody] CreateReservationDto dto)
    {
        try
        {
            // ‚ö†Ô∏è SOLO DELEGAR AL SERVICIO
            var result = await _reservationService.CreateReservationAsync(dto);
            return CreatedAtAction(nameof(GetReservation), 
                new { id = result.Id }, result);
        }
        catch (InvalidOperationException ex)
        {
            // ‚ö†Ô∏è CONVERTIR EXCEPCIONES A HTTP STATUS CODES
            return BadRequest(new { error = ex.Message });
        }
    }
    
    // GET /api/reservations?email=test@example.com
    [HttpGet]
    public async Task<ActionResult<IEnumerable<ReservationDto>>> 
        GetReservationsByGuest([FromQuery] string email)
    {
        var reservations = await _reservationService
            .GetReservationsByGuestAsync(email);
        return Ok(reservations);
    }
}

// Program.cs (Dependency Injection)
var builder = WebApplicationBuilder.CreateBuilder(args);

// ‚ö†Ô∏è REGISTRAR DEPENDENCIAS
builder.Services.AddScoped<IReservationRepository, ReservationRepository>();
builder.Services.AddScoped<IReservationService, ReservationService>();
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(connectionString));

var app = builder.Build();
app.MapControllers();
app.Run();
```

**Qu√© ves aqu√≠:**
- ‚úÖ **Thin controller:** Solo recibe HTTP, delega a servicio
- ‚úÖ **Conversi√≥n HTTP:** Traduce excepciones a status codes
- ‚úÖ **DI:** Registra todas las dependencias
- ‚úÖ **Sin l√≥gica:** Aqu√≠ NO debe haber if/else de negocio

**Por qu√© es importante:**
- Ma√±ana necesitas exponer la API en gRPC = creas otro adapter
- Los servicios siguen igual
- La l√≥gica sigue en Application

---

## üìä FLUJO COMPLETO: UNA PETICI√ìN HTTP

```
1. HTTP REQUEST
   POST /api/reservations
   {
     "hotelId": 1,
     "guestName": "Juan",
     "checkInDate": "2026-02-20",
     "checkOutDate": "2026-02-22"
   }
   
   ‚Üì
   
2. PRESENTATION (ReservationsController)
   - Recibe JSON
   - Deserializa a CreateReservationDto
   - Llama: _reservationService.CreateReservationAsync(dto)
   - ‚ö†Ô∏è AQU√ç NO HAY L√ìGICA
   
   ‚Üì
   
3. APPLICATION (ReservationService)
   - Recibe CreateReservationDto
   - PASO A: Consulta hotel ‚Üí _hotelRepository.GetByIdAsync(1)
   - PASO B: Crea entidad Reservation
   - PASO C: Valida ‚Üí reservation.IsValidReservation()
   - PASO D: Calcula precio ‚Üí reservation.CalculatePrice(100m)
   - PASO E: Persiste ‚Üí _reservationRepository.AddAsync(reservation)
   - PASO F: Guarda cambios ‚Üí _reservationRepository.SaveChangesAsync()
   - PASO G: Convierte a DTO
   - Retorna ReservationDto
   - ‚ö†Ô∏è AQU√ç EST√Å TODA LA L√ìGICA
   
   ‚Üì
   
4. INFRASTRUCTURE (ReservationRepository + DbContext)
   - Recibe entidad Reservation
   - Ejecuta SQL (impl√≠cito en EF Core)
   - INSERT INTO Reservations (...)
   - Retorna ID generado
   - ‚ö†Ô∏è AQU√ç EST√Å LA BD
   
   ‚Üì
   
5. DOMAIN (Reservation entity)
   - IsValidReservation() ‚Üí retorna true
   - CalculatePrice() ‚Üí retorna 200m (2 noches √ó 100)
   - ‚ö†Ô∏è SIN EFECTOS SECUNDARIOS
   
   ‚Üì
   
6. HTTP RESPONSE
   201 Created
   {
     "id": 123,
     "guestName": "Juan",
     "status": "Pending",
     "totalPrice": 200
   }
```

---

## üéØ LO QUE DEBES ENTENDER DEL NEGOCIO

### NEGOCIO = DOMAIN

El negocio de Hoteles San Bernardo es:

```csharp
// ¬øQu√© es una reserva?
public class Reservation
{
    // Estas propiedades DEFINEN una reserva
    public int HotelId { get; set; }
    public string GuestName { get; set; }
    public DateTime CheckInDate { get; set; }
    public DateTime CheckOutDate { get; set; }
    public ReservationStatus Status { get; set; }
    
    // ¬øQu√© REGLAS tiene una reserva?
    public bool IsValidReservation()
    {
        // Regla de negocio 1: La salida debe ser despu√©s de entrada
        if (CheckOutDate <= CheckInDate)
            return false;
        
        // Regla de negocio 2: El nombre es obligatorio
        if (string.IsNullOrEmpty(GuestName))
            return false;
        
        return true;
    }
    
    // ¬øC√≥mo se CALCULA el precio?
    public decimal CalculatePrice(decimal nightlyRate)
    {
        int nights = (CheckOutDate - CheckInDate).Days;
        return nights * nightlyRate;
    }
}

// ¬øQu√© ESTADOS puede tener una reserva?
public enum ReservationStatus
{
    Pending = 1,      // Acaba de crearse
    Confirmed = 2,    // Admin confirm√≥
    Cancelled = 3     // Cliente o admin cancel√≥
}
```

**Esto NO cambiar√≠a aunque:**
- Cambies de BD
- Cambies de framework
- Expongas la API en REST, gRPC o GraphQL
- Tengas 1 usuario o 1 mill√≥n

---

## üîÑ CAMBIOS T√çPICOS Y D√ìNDE AFECTAN

### ESCENARIO 1: "Necesitamos guardar reservas en MongoDB en vez de PostgreSQL"

```
Domain:        ‚ùå NO CAMBIA (Reservation.cs es igual)
Application:   ‚ùå NO CAMBIA (ReservationService.cs es igual)
Infrastructure: ‚úÖ S√ç CAMBIA
   Antes: PostgreSQL + EF Core
   Ahora: MongoDB + MongoDB Driver
   Cambio:
   - Reemplazas ReservationRepository con versi√≥n MongoDB
   - AppDbContext ‚Üí MongoDbContext
   IReservationRepository sigue igual (interfaz no cambia)
Presentation:  ‚ùå NO CAMBIA (Controller es igual)
```

---

### ESCENARIO 2: "El c√°lculo de precio tiene descuento por cantidad de noches"

```
Domain:        ‚úÖ S√ç CAMBIA
   CalculatePrice(nightlyRate) ‚Üí
   CalculatePrice(nightlyRate, discountPercentage)
   
   public decimal CalculatePrice(decimal nightlyRate, int discount = 0)
   {
       int nights = (CheckOutDate - CheckInDate).Days;
       decimal price = nights * nightlyRate;
       
       // Nueva l√≥gica de descuento
       if (nights >= 7)
           price *= (1 - (discount / 100m));
           
       return price;
   }

Application:   ‚úÖ S√ç CAMBIA
   ReservationService.CreateReservationAsync()
   // Ahora necesita el descuento
   reservation.TotalPrice = reservation.CalculatePrice(nightlyRate, 10);

Infrastructure: ‚ùå NO CAMBIA (Solo guardamos el price)
Presentation:   ‚ùå NO CAMBIA (El DTO retorna lo mismo)
```

---

### ESCENARIO 3: "Necesitamos exponer los datos en GraphQL adem√°s de REST"

```
Domain:        ‚ùå NO CAMBIA
Application:   ‚ùå NO CAMBIA
Infrastructure: ‚ùå NO CAMBIA
Presentation:  ‚úÖ S√ç CAMBIA
   Antes: ReservationsController (REST)
   Ahora: ReservationsQuery (GraphQL)
   
   Ambos usan: IReservationService (mismo servicio)
```

---

## üí° PRINCIPIOS CLAVE

### 1Ô∏è‚É£ INVERSI√ìN DE DEPENDENCIAS (Dependency Inversion Principle)

```csharp
// ‚ùå MAL (Acoplamiento directo)
public class ReservationService
{
    private PostgresRepository _repository; // Concreto
    
    public ReservationService()
    {
        _repository = new PostgresRepository(); // Hardcoded
    }
}
// Problema: Si cambias a MongoDB, rompes el c√≥digo

// ‚úÖ BIEN (Desacoplado)
public class ReservationService
{
    private IReservationRepository _repository; // Interfaz
    
    public ReservationService(IReservationRepository repository) // DI
    {
        _repository = repository;
    }
}
// Beneficio: Inyectas PostgresRepository o MongoDbRepository sin cambiar el c√≥digo
```

---

### 2Ô∏è‚É£ SEPARACI√ìN DE RESPONSABILIDADES (Single Responsibility)

```
Domain:
  ¬øQu√© hace? Define entidades y reglas de negocio
  ¬øQui√©n la cambia? Product owner (cambios en reglas)

Application:
  ¬øQu√© hace? Orquesta el flujo de casos de uso
  ¬øQui√©n la cambia? Dev backend (nuevas funcionalidades)

Infrastructure:
  ¬øQu√© hace? Implementa detalles t√©cnicos (BD, APIs externas)
  ¬øQui√©n la cambia? DevOps (cambios de BD o librer√≠as)

Presentation:
  ¬øQu√© hace? Expone la API
  ¬øQui√©n la cambia? Dev backend/frontend (nuevos endpoints)
```

---

### 3Ô∏è‚É£ INDEPENDENCIA DE FRAMEWORKS

```csharp
// Domain NO depende de ASP.NET
public class Reservation
{
    // ‚úÖ Esto compilar√≠a incluso sin ASP.NET instalado
    public decimal CalculatePrice(decimal rate) { ... }
}

// Domain NO depende de Entity Framework
// Reservation.cs es PURO C#

// Application S√ç depende de interfaces
// pero NO de implementaciones concretas
public class ReservationService : IReservationService
{
    // Recibe interfaz, no conoce PostgreSQL
    public ReservationService(IReservationRepository repo) { }
}
```

---

## üß™ TESTING (POR QU√â CLEAN ARCHITECTURE FACILITA TESTS)

```csharp
// Tests de Domain (puro negocio, ultra r√°pidos)
[TestClass]
public class ReservationTests
{
    [TestMethod]
    public void CalculatePrice_WithValidNights_ReturnsTotalPrice()
    {
        // Arrange
        var reservation = new Reservation
        {
            CheckInDate = new DateTime(2026, 2, 1),
            CheckOutDate = new DateTime(2026, 2, 3) // 2 noches
        };
        
        // Act
        var price = reservation.CalculatePrice(100m);
        
        // Assert
        Assert.AreEqual(200m, price); // 2 noches √ó 100
    }
}

// Tests de Application (con mocks)
[TestClass]
public class ReservationServiceTests
{
    [TestMethod]
    public async Task CreateReservation_WithValidData_ReturnsReservationDto()
    {
        // Arrange
        var mockRepo = new Mock<IReservationRepository>();
        var service = new ReservationService(mockRepo.Object);
        
        // Act
        var result = await service.CreateReservationAsync(new CreateReservationDto
        {
            HotelId = 1,
            GuestName = "Juan",
            CheckInDate = new DateTime(2026, 2, 1),
            CheckOutDate = new DateTime(2026, 2, 3)
        });
        
        // Assert
        Assert.IsNotNull(result);
        mockRepo.Verify(r => r.AddAsync(It.IsAny<Reservation>()), Times.Once);
    }
}

// Tests de Controllers (tambi√©n con mocks)
[TestClass]
public class ReservationsControllerTests
{
    [TestMethod]
    public async Task CreateReservation_WithValidRequest_Returns201()
    {
        // Arrange
        var mockService = new Mock<IReservationService>();
        var controller = new ReservationsController(mockService.Object);
        
        // Act
        var result = await controller.CreateReservation(new CreateReservationDto { ... });
        
        // Assert
        Assert.IsInstanceOfType(result.Result, typeof(CreatedAtActionResult));
    }
}
```

**Por qu√© es m√°s f√°cil:**
- Domain tests = sin mocks, sin BD, super r√°pidos (microsegundos)
- Application tests = mocks de repositorios, sin BD, r√°pidos (milisegundos)
- Controller tests = mocks de servicios, sin HTTP, r√°pidos (milisegundos)

---

## üìã CHECKLIST: ¬øEST√Å MI PROYECTO EN CLEAN ARCHITECTURE?

```
DOMAIN LAYER:
‚òê Las entidades NO importan DbContext
‚òê Las entidades NO importan HttpClient
‚òê Las entidades NO importan nada de Infrastructure
‚òê M√©todos como IsValidReservation() existen en entidades
‚òê M√©todos como CalculatePrice() existen en entidades

APPLICATION LAYER:
‚òê Los servicios inyectan interfaces (IReservationRepository)
‚òê Los servicios NO hacen new ReservationRepository()
‚òê Los servicios contienen la l√≥gica de flujo
‚òê Los servicios orquestan Domain + Infrastructure
‚òê Los servicios retornan DTOs, no entidades

INFRASTRUCTURE LAYER:
‚òê Los repositorios implementan interfaces del Domain
‚òê Los repositorios hablan con la BD
‚òê DbContext vive aqu√≠
‚òê Sin l√≥gica de negocio aqu√≠
‚òê Solo read/write de datos

PRESENTATION LAYER:
‚òê Los controllers reciben servicios (IReservationService)
‚òê Los controllers NO instancian repositorios
‚òê Los controllers son thin (pocas l√≠neas)
‚òê Los controllers convierten excepciones a HTTP status codes
‚òê Sin l√≥gica de negocio en controllers
```

---

## üéì RESUMEN FINAL

### Clean Architecture en 1 minuto:

```
EXTERIOR (lo que cambia frecuentemente):
  - Frameworks (ASP.NET, Angular)
  - BD (PostgreSQL, MongoDB)
  - UI (REST, GraphQL, gRPC)
  
INTERIOR (lo que nunca cambia):
  - Reglas de negocio (una reserva necesita CheckIn < CheckOut)
  - Entidades (Hotel, Reservation)
  - Interfaces de repositorio

PRINCIPIO CENTRAL:
  Domain NO conoce nada del exterior
  Exterior DEBE conocer Domain
  
FLUJO:
  Exterior (HTTP) ‚Üí Presentation ‚Üí Application ‚Üí Infrastructure ‚Üí Domain
  Domain (respuesta) ‚Üê Infrastructure ‚Üê Application ‚Üê Presentation ‚Üê Exterior
```

---

## üí¨ EN TUS PROPIAS PALABRAS

**Si alguien te pregunta en una entrevista:** "¬øC√≥mo explicar√≠as Clean Architecture?"

**Respuesta perfecta:**
"Clean Architecture es separar el c√≥digo en capas: Domain es el n√∫cleo que contiene las reglas de negocio puro (sin dependencias), Application orquesta casos de uso usando esas reglas, Infrastructure maneja los detalles t√©cnicos como la BD, y Presentation expone la API.

La regla clave es que las dependencias siempre apuntan hacia adentro: Domain no conoce nada, Application conoce Domain, Infrastructure conoce Domain y Application, y Presentation conoce Application.

Por ejemplo, en mi proyecto de reservas, la entidad Reservation en Domain define qu√© es una reserva y c√≥mo calcular precios. ReservationService en Application orquesta el flujo de crear una reserva. ReservationRepository en Infrastructure maneja PostgreSQL. Y ReservationsController en Presentation expone el endpoint REST.

Si ma√±ana cambio de PostgreSQL a MongoDB, solo cambio Infrastructure. Si cambio de REST a GraphQL, solo cambio Presentation. La l√≥gica de negocio nunca cambia."

---

**Creado:** 2026-02-10  
**Versi√≥n:** 1.0  
**Estado:** ‚úÖ Listo para entrevista t√©cnica